//#############################################################################
//
// FILE:   clllc.h
//
// TITLE: This is the solution header file.
//
//#############################################################################
// $TI Release: TIDM_02002 v2.00.05.00 $
// $Release Date: Thu Dec 14 13:13:02 CST 2023 $
// $Copyright:
// Copyright (C) 2023 Texas Instruments Incorporated - http://www.ti.com/
//
// ALL RIGHTS RESERVED
// $
//#############################################################################

#ifndef CLLLC_H
#define CLLLC_H

#ifdef __cplusplus

extern "C" {
#endif

//
// the includes & defines
//
#include <stdint.h>
#include <stddef.h>

#ifndef __TMS320C28XX_CLA__
#include <math.h>
#else
#include <CLAmath.h>
#endif

//
// this is the file generated by the powerSUITE page for this system
//
#include "clllc_settings.h"
#include "clllc_hal.h"

//
// Library header files
// DCL Library is used for the controller implementation
// GI -> DF13,
// GV -> DF13,
//

#ifndef __TMS320C28XX_CLA__
#include "DCLF32.h"
#define CLLLC_GI DCL_DF13
#define CLLLC_GV DCL_DF13

//
// GI on C28x ,run DCL_DF13 routines
//
#define CLLLC_GI_IMMEDIATE_RUN DCL_runDF13_C5
#define CLLLC_GI_PRECOMPUTE_RUN DCL_runDF13_C6

//
// GV on C28x ,run DCL_DF13 routines
//
#define CLLLC_GV_RUN DCL_runDF13_C4
#define CLLLC_GV_IMMEDIATE_RUN DCL_runDF13_C5
#define CLLLC_GV_PRECOMPUTE_RUN DCL_runDF13_C6

#else
#include "DCLCLA.h"
#define CLLLC_GI DCL_DF13_CLA
#define CLLLC_GV DCL_DF13_CLA

//
// GI on C28x ,run DCL_DF13 routines
//
#define CLLLC_GI_IMMEDIATE_RUN CLLLC_runDF13_L5
#define CLLLC_GI_PRECOMPUTE_RUN CLLLC_runDF13_L6

//
// GV on C28x ,run DCL_DF13 routines
//
#define CLLLC_GV_IMMEDIATE_RUN CLLLC_runDF13_L5
#define CLLLC_GV_PRECOMPUTE_RUN CLLLC_runDF13_L6

#pragma FUNC_ALWAYS_INLINE(CLLLC_runDF13_L5)
#pragma FUNC_ALWAYS_INLINE(CLLLC_runDF13_L6)

//
//! \brief          Executes an immediate 3rd order Direct Form 1 controller on
//!                 the FPU32, Implemented as inline C function
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] vk   The partial pre-computed control effort
//! \return         The control effort
//!
static inline float32_t CLLLC_runDF13_L5(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t vk)
{
    p->d4 = (ek * p->b0) + vk;

    return(p->d4);
}

//
//! \brief          Executes a partial pre-computed 3rd order
//!                 Direct Form 1 controller on the FPU32
//!                 Implemented as inline C function
//!                 Note: d0 not used
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] uk   The controller output in the previous sample interval
//! \return         The control effort
//!
//
static inline float32_t CLLLC_runDF13_L6(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t uk)
{
    float32_t v9;

    v9 = (ek * p->b1) + (p->d1 * p->b2) + (p->d2 * p->b3)
         - (uk * p->a1) - (p->d5 * p->a2) - (p->d6 * p->a3);
    p->d2 = p->d1;
    p->d1 = ek;
    p->d6 = p->d5;
    p->d5 = uk;

    return(v9);
}

#endif

#include "dlog_4ch.h"
#include "emavg.h"

#pragma FUNC_ALWAYS_INLINE(EPWM_setActionQualifierContSWForceAction)

#ifndef __TMS320C28XX_CLA__
#include "sfra_f32.h"
#include "sfra_gui_scicomms_driverlib.h"
#define CLLLC_SFRA_INJECT SFRA_F32_inject
#define CLLLC_SFRA_COLLECT SFRA_F32_collect
#else
#define CLLLC_SFRA_INJECT(m)    m
#define CLLLC_SFRA_COLLECT(m, n)
#endif

//
// Function to run the ISR3, for details see dataflow diagram in the user guide
//
void CLLLC_runISR3(void);

//
// Function initialize the global variables
//
void CLLLC_initGlobalVariables(void);

//
// Function reads the trip flags and updates the board status enum type variable
//
void CLLLC_updateBoardStatus(void);

//
//
//
void CLLLC_runSFRABackGroundTasks(void);


//
//
//
void CLLLC_setBuildLevelIndicatorVariable(void);
void CLLLC_changeSynchronousRectifierPwmBehavior(uint16_t powerFlow);

#ifndef __TMS320C28XX_CLA__
void CLLLC_setupSFRA();
#else
#endif

//
// typedefs
//

typedef union{
    enum
    {
        Lab1 = 0,
        Lab1_CLA = 1,
        Lab2 = 2,
        Lab2_CLA = 3,
        Lab3 = 4,
        Lab3_CLA = 5,
        Lab4 = 6,
        Lab4_CLA = 7,
        Lab5 = 8,
        Lab5_CLA = 9,
        Lab6 = 10,
        Lab6_CLA = 11,
        Lab7 = 12,
        Lab7_CLA = 13,
        Lab8 = 14,
        Lab8_CLA = 15,
        undefinedLab = 12,
    }CLLLC_Lab_Enum;
    int32_t pad;
}CLLLC_Lab_EnumType;

extern  CLLLC_Lab_EnumType CLLLC_lab;

typedef union{
    enum
    {
        noTrip = 0,
        primOverCurrentTrip = 1,
        secOverCurrentTrip = 2,
        primOverVoltageTrip = 3,
        secOverVoltageTrip = 4,
        primTankOverCurrentTrip = 5,
    }CLLLC_TripFlag_Enum;
    int32_t pad;
}CLLLC_TripFlag_EnumType;

extern  CLLLC_TripFlag_EnumType CLLLC_TripFlag;

typedef union{
    enum
    {
        pwmSwState_disabledAll = 0,
        pwmSwState_synchronousRectification_OFF = 1,
        pwmSwState_synchronousRectification_fixedDuty = 2,
        pwmSwState_synchronousRectification_active = 3
    }CLLLC_PwmSwState_Enum;
    int32_t pad;
}CLLLC_PwmSwState_EnumType;

extern  CLLLC_PwmSwState_EnumType CLLLC_pwmSwStateActive, CLLLC_pwmSwState;

typedef union{
    enum
    {
        powerFlow_PrimToSec = CLLLC_POWER_FLOW_PRIM_SEC,
        powerFlow_SecToPrim = CLLLC_POWER_FLOW_SEC_PRIM,
        powerFlow_intermediateState = CLLLC_POWER_FLOW_TRANSTION_STAGE,
    }CLLLC_PowerFlowState_Enum;
    int32_t pad;
}CLLLC_PowerFlowState_EnumType;

extern  CLLLC_PowerFlowState_EnumType CLLLC_powerFlowStateActive,
                                  CLLLC_powerFlowState;

typedef union{
    enum
    {
        ac_dc_OFF = 0,
        ac_dc_PFC = 1,
        ac_dc_INV = 2,
    }CLLLC_CommandSentTo_AC_DC_Enum;
    int32_t pad;
}CLLLC_CommandSentTo_AC_DC_EnumType;

extern  CLLLC_CommandSentTo_AC_DC_EnumType CLLLC_commandSentTo_AC_DC;

//
// globals
//

extern CLLLC_GI CLLLC_gi;
extern float32_t CLLLC_giOut;
extern float32_t CLLLC_giError;
extern float32_t CLLLC_giPartialComputedValue;

extern CLLLC_GV CLLLC_gv;
extern float32_t CLLLC_gvOut;
extern float32_t CLLLC_gvError;
extern float32_t CLLLC_gvPartialComputedValue;

//
// Flags for clearing trips and closing the loop
//
extern volatile int32_t CLLLC_closeGiLoop;
extern volatile int32_t CLLLC_closeGvLoop;
extern volatile int32_t CLLLC_clearTrip;

extern volatile float32_t CLLLC_pwmFrequencyRef_Hz;
extern volatile float32_t CLLLC_pwmFrequency_Hz;
extern volatile float32_t CLLLC_pwmFrequencyPrev_Hz;

extern volatile float32_t CLLLC_pwmPeriodRef_pu;
extern float32_t CLLLC_pwmPeriod_pu;
extern float32_t CLLLC_pwmPeriodSlewed_pu;
extern float32_t CLLLC_pwmPeriodMin_pu;
extern float32_t CLLLC_pwmPeriodMax_pu;
extern float32_t CLLLC_pwmPeriodMax_ticks;
extern uint32_t CLLLC_pwmPeriod_ticks;

//
// 1- Primary Side (PFC-Inv/Bus)
//
extern float32_t CLLLC_iPrimSensed_Amps;
extern float32_t CLLLC_iPrimSensed_pu;
extern float32_t CLLLC_iPrimSensedOffset_pu;
extern float32_t CLLLC_iPrimSensedCalIntercept_pu;
extern float32_t CLLLC_iPrimSensedCalXvariable_pu;
extern EMAVG CLLLC_iPrimSensedAvg_pu;

extern float32_t CLLLC_iPrimTankSensed_Amps;
extern float32_t CLLLC_iPrimTankSensed_pu;
extern float32_t CLLLC_iPrimTankSensedOffset_pu;
extern float32_t CLLLC_iPrimTankSensedCalIntercept_pu;
extern float32_t CLLLC_iPrimTankSensedCalXvariable_pu;
extern EMAVG CLLLC_iPrimTankSensedAvg_pu;

extern float32_t CLLLC_vPrimSensed_Volts;
extern float32_t CLLLC_vPrimSensed_pu;
extern float32_t CLLLC_vPrimSensedOffset_pu;
extern EMAVG CLLLC_vPrimSensedAvg_pu;

extern float32_t CLLLC_vPrimRef_Volts;
extern float32_t CLLLC_vPrimRef_pu;
extern float32_t CLLLC_vPrimRefSlewed_pu;

extern volatile float32_t CLLLC_pwmDutyPrimRef_pu;
extern float32_t CLLLC_pwmDutyPrim_pu;
extern uint32_t CLLLC_pwmDutyAPrim_ticks;
extern uint32_t CLLLC_pwmDutyBPrim_ticks;

extern volatile float32_t CLLLC_pwmDeadBandREDPrimRef_ns;
extern uint32_t CLLLC_pwmDeadBandREDPrim_ticks;

extern volatile float32_t CLLLC_pwmDeadBandFEDPrimRef_ns;
extern uint32_t CLLLC_pwmDeadBandFEDPrim_ticks;

//
// 2-Secondary side (Battery)
//
extern float32_t CLLLC_iSecSensed_Amps;
extern float32_t CLLLC_iSecSensed_pu;
extern float32_t CLLLC_iSecSensedOffset_pu;
extern float32_t CLLLC_iSecSensedCalIntercept_pu;
extern float32_t CLLLC_iSecSensedCalXvariable_pu;
extern EMAVG CLLLC_iSecSensedAvg_pu;

extern volatile float32_t CLLLC_iSecRef_Amps;
extern float32_t CLLLC_iSecRef_pu;
extern float32_t CLLLC_iSecRefSlewed_pu;

extern float32_t CLLLC_vSecSensed_Volts;
extern float32_t CLLLC_vSecSensed_pu;
extern float32_t CLLLC_vSecSensedOffset_pu;

extern float32_t CLLLC_vSecRef_Volts;
extern float32_t CLLLC_vSecRef_pu;
extern float32_t CLLLC_vSecRefSlewed_pu;
extern EMAVG CLLLC_vSecSensedAvg_pu;

extern volatile float32_t CLLLC_pwmDutySecRef_pu;
extern float32_t CLLLC_pwmDutySec_pu;
extern uint32_t CLLLC_pwmDutyASec_ticks;
extern uint32_t CLLLC_pwmDutyBSec_ticks;

extern float32_t CLLLC_pwmDeadbandREDSec_ns;
extern uint16_t CLLLC_pwmDeadbandREDSec_ticks;

extern float32_t CLLLC_pwmDeadBandFEDSec_ns;
extern uint16_t CLLLC_pwmDeadbandFEDSec_ticks;

extern volatile float32_t CLLLC_pwmPhaseShiftPrimSecRef_ns;
extern float32_t CLLLC_pwmPhaseShiftPrimSec_ns;
extern int32_t CLLLC_pwmPhaseShiftPrimSec_ticks;
extern int16_t CLLLC_pwmPhaseShiftPrimSec_countDirection;


extern volatile uint16_t CLLLC_pwmISRTrig_ticks;

extern volatile uint32_t CLLLC_cla_task_counter;

extern uint32_t CLLLC_slewSCIcommand;

#ifndef __TMS320C28XX_CLA__
//
// datalogger
//
extern DLOG_4CH CLLLC_dLog1;
extern float32_t CLLLC_dBuff1[100],
                 CLLLC_dBuff2[100],
                 CLLLC_dBuff3[100],
                 CLLLC_dBuff4[100];
extern float32_t CLLLC_dVal1,
                 CLLLC_dVal2,
                 CLLLC_dVal3,
                 CLLLC_dVal4;
extern volatile float32_t CLLLC_dlogTrigger;

#if CLLLC_SFRA_TYPE != CLLLC_SFRA_DISABLED
extern float32_t CLLLC_plantMagVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_plantPhaseVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_olMagVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_olPhaseVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_freqVect[CLLLC_SFRA_FREQ_LENGTH];
#endif

extern SFRA_F32 CLLLC_sfra1;
extern int16_t SerialCommsTimer;
extern int16_t initializationFlag;
extern int16_t *varSetTxtList[];
extern int16_t *varSetBtnList[];
extern int16_t *varSetSldrList[];
extern int16_t *varGetList[];
extern int32_t *arrayGetList[];
extern int16_t *dataGetList[];
extern uint32_t *dataSetList[];

extern int16_t CommsOKflg, SerialCommsTimer;
#endif

//
// the function prototypes
//
#pragma FUNC_ALWAYS_INLINE(CLLLC_readSensedSignalsPrimToSecPowerFlow)
static inline void CLLLC_readSensedSignalsPrimToSecPowerFlow(void)
{
    CLLLC_iPrimSensed_pu = ((float32_t)CLLLC_IPRIM_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iPrimSensedOffset_pu) * -2.0;

    CLLLC_iSecSensed_pu =  ((float32_t)CLLLC_ISEC_OVERSAMPLE_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iSecSensedOffset_pu) * 2.0;
    CLLLC_vPrimSensed_pu = ((float32_t)CLLLC_VPRIM_OVERSAMPLE_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vPrimSensedOffset_pu);
    CLLLC_vSecSensed_pu =  ( (float32_t)CLLLC_VSEC_OVERSAMPLE_ADCREAD *
                                        CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vSecSensedOffset_pu);

    CLLLC_vSecSensed_pu = CLLLC_vSecSensed_pu *
                  (CLLLC_VSEC_MAX_SENSE_VOLTS / CLLLC_VSEC_OPTIMAL_RANGE_VOLTS);

    CLLLC_iSecSensed_pu = (CLLLC_iSecSensed_pu *
                           CLLLC_iSecSensedCalXvariable_pu) +
                           CLLLC_iSecSensedCalIntercept_pu;
    CLLLC_iPrimSensed_pu = (CLLLC_iPrimSensed_pu *
                            CLLLC_iPrimSensedCalXvariable_pu) +
                            CLLLC_iPrimSensedCalIntercept_pu;
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_readSensedSignalsSecToPrimPowerFlow)
static inline void CLLLC_readSensedSignalsSecToPrimPowerFlow(void)
{
    CLLLC_iPrimSensed_pu = ((float32_t)CLLLC_IPRIM_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iPrimSensedOffset_pu) * -2.0;

    CLLLC_iSecSensed_pu =  ((float32_t)CLLLC_ISEC_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iSecSensedOffset_pu) * 2.0;
    CLLLC_vPrimSensed_pu = ((float32_t)CLLLC_VPRIM_OVERSAMPLE_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vPrimSensedOffset_pu);
    CLLLC_vSecSensed_pu =  ( (float32_t)CLLLC_VSEC_ADCREAD *
                                        CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vSecSensedOffset_pu);

    CLLLC_vSecSensed_pu = CLLLC_vSecSensed_pu *
                  (CLLLC_VSEC_MAX_SENSE_VOLTS / CLLLC_VSEC_OPTIMAL_RANGE_VOLTS);

    CLLLC_iSecSensed_pu = (CLLLC_iSecSensed_pu *
                           CLLLC_iSecSensedCalXvariable_pu) +
                           CLLLC_iSecSensedCalIntercept_pu;
    CLLLC_iPrimSensed_pu = (CLLLC_iPrimSensed_pu *
                            CLLLC_iPrimSensedCalXvariable_pu) +
                            CLLLC_iPrimSensedCalIntercept_pu;
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow)
static inline void CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(CLLLC_pwmPeriodSlewed_pu *
                                   CLLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLLC_pwmDutyPrim_pu)));

    CLLLC_pwmDutyBPrim_ticks = CLLLC_pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLLC_pwmDutyAPrim_ticks & 0x00FF00) == 0)
    {
        CLLLC_pwmDutyAPrim_ticks = CLLLC_pwmDutyAPrim_ticks | 0x000100;
    }

    //
    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    CLLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLLC_pwmDutySec_pu))) << 1;

    //
    // for secondary side B ticks = period - duty_a
    //
    CLLLC_pwmDutyBSec_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyASec_ticks;

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLLC_pwmPeriod_ticks >> 1) -
             (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimSec_ns *
                       CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));

    //
    // remove the hi-res part for the prim-sec shift
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks = CLLLC_pwmPhaseShiftPrimSec_ticks &
                                        0xFFFF0000;

}

#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow)
static inline void CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(CLLLC_pwmPeriod_pu *
                                   CLLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLLC_pwmDutySec_pu)));

    CLLLC_pwmDutyBSec_ticks = CLLLC_pwmDutyASec_ticks;

    //
    // for prim side, dutyA = period * duty_pu * 2.0 (<<1) because the duty is
    // not centered around zero or period
    //
    CLLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLLC_pwmDutyPrim_pu))) << 1;

    //
    // dutyB = period - dutyA
    //
    CLLLC_pwmDutyBPrim_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLLC_pwmDutyASec_ticks & 0x00FF00) == 0)
    {
        CLLLC_pwmDutyASec_ticks = CLLLC_pwmDutyASec_ticks | 0x000100;
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLLC_pwmPeriod_ticks >> 1) +
             (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimSec_ns *
                       CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));

}


#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDeadBandPrimTicks)
static inline void CLLLC_calculatePWMDeadBandPrimTicks(void)
{
    uint32_t ticks;

    //
    // as we use double clock for the deadband there is a multiple by 2,
    // red_ticks= red_ns*pwm_clk_hz*one_ns*2^16
    // 2^16 multiply is (because of high res)
    //
    ticks = ((uint32_t)(CLLLC_pwmDeadBandREDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * CLLLC_PWMSYSCLOCK_FREQ_HZ * 2.0f));
    CLLLC_pwmDeadBandREDPrim_ticks = ( ticks & 0xFFFFFE00);

    ticks = ((uint32_t)(CLLLC_pwmDeadBandFEDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * CLLLC_PWMSYSCLOCK_FREQ_HZ * 2.0f));
    CLLLC_pwmDeadBandFEDPrim_ticks = ( ticks & 0xFFFFFE00);

}
#pragma FUNC_ALWAYS_INLINE(EPWM_setCounterCompareValue)
#pragma FUNC_ALWAYS_INLINE(EPWM_enablePhaseShiftLoad)
#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR1)
static inline void CLLLC_runISR1(void)
{
    CLLLC_HAL_updatePWMDutyPeriodPhaseShift(CLLLC_pwmPeriod_ticks,
                      CLLLC_pwmDutyAPrim_ticks,
                      CLLLC_pwmDutyBPrim_ticks,
                      CLLLC_pwmDutyASec_ticks,
                      CLLLC_pwmDutyBSec_ticks,
                      CLLLC_pwmPhaseShiftPrimSec_ticks);

    EPWM_enablePhaseShiftLoad(CLLLC_SEC_LEG1_PWM_BASE);
    EPWM_enablePhaseShiftLoad(CLLLC_SEC_LEG2_PWM_BASE);

    //
    //  EPWM_setCounterCompareValue(CLLLC_ISR1_PERIPHERAL_TRIG_BASE,
    //                          EPWM_COUNTER_COMPARE_C, CLLLC_pwmISRTrig_ticks);
    //

    //
    // write to COMPC or COMPD bits
    //
    #pragma diag_suppress = 173
    HWREGH(CLLLC_ISR1_PERIPHERAL_TRIG_BASE + EPWM_O_CMPC) =
                                        CLLLC_pwmISRTrig_ticks;
    #pragma diag_warning = 173

    CLLLC_HAL_clearISR1PeripheralInterruptFlag();
}


#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR1_secondTime)
static inline void CLLLC_runISR1_secondTime(void)
{
    EPWM_disablePhaseShiftLoad(CLLLC_SEC_LEG1_PWM_BASE);
    EPWM_disablePhaseShiftLoad(CLLLC_SEC_LEG2_PWM_BASE);
    CLLLC_HAL_setupISR1Trigger(CLLLC_MIN_PWM_SWITCHING_FREQUENCY_HZ * 0.3);
    CLLLC_HAL_clearISR1PeripheralInterruptFlag();
}


#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR2_primToSecPowerFlow)
static inline void CLLLC_runISR2_primToSecPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    CLLLC_readSensedSignalsPrimToSecPowerFlow();

    if(CLLLC_clearTrip == 1)
    {
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG2_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG2_PWM_BASE);

        #if CLLLC_TEST_SETUP == CLLLC_TEST_SETUP_EMULATED_BATTERY
            CLLLC_closeGiLoop = 1;
        #endif

        CLLLC_clearTrip = 0;
    }

    if(CLLLC_closeGiLoop == 1)//闭电流环
    {
        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT
            CLLLC_giError = (CLLLC_SFRA_INJECT(CLLLC_iSecRefSlewed_pu) -
                                             CLLLC_iSecSensed_pu);
        #else
            CLLLC_giError = (CLLLC_iSecRefSlewed_pu - CLLLC_iSecSensed_pu);
        #endif

        CLLLC_giOut = CLLLC_GI_IMMEDIATE_RUN(&CLLLC_gi,
                                       CLLLC_giError,
                                       CLLLC_giPartialComputedValue);

        if(CLLLC_giOut > CLLLC_GI_OUT_MAX)
        {
            CLLLC_giOut = CLLLC_GI_OUT_MAX;
        }
        if(CLLLC_giOut < CLLLC_GI_OUT_MIN)
        {
            CLLLC_giOut = CLLLC_GI_OUT_MIN;
        }

        CLLLC_giPartialComputedValue = CLLLC_GI_PRECOMPUTE_RUN(&CLLLC_gi,
                                                        CLLLC_giError,
                                                        CLLLC_giOut);

        if(CLLLC_giOut < CLLLC_pwmPeriodMin_pu)
        {
            CLLLC_giOut = CLLLC_pwmPeriodMin_pu;
        }

        CLLLC_pwmPeriod_pu = CLLLC_giOut;
    }
    else if(CLLLC_closeGvLoop == 1)//闭电压环
    {

        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
            CLLLC_gvError = (CLLLC_SFRA_INJECT(CLLLC_vSecRefSlewed_pu) -
                                              CLLLC_vSecSensed_pu);
        #else
            CLLLC_gvError = (CLLLC_vSecRefSlewed_pu - CLLLC_vSecSensed_pu);
        #endif

        CLLLC_gvOut = CLLLC_GV_IMMEDIATE_RUN(&CLLLC_gv,
                                       CLLLC_gvError,
                                       CLLLC_gvPartialComputedValue);

        if(CLLLC_gvOut > CLLLC_GV_OUT_MAX)//环路输出限幅
        {
            CLLLC_gvOut = CLLLC_GV_OUT_MAX;
        }
        if(CLLLC_gvOut < CLLLC_GV_OUT_MIN)
        {
            CLLLC_gvOut = CLLLC_GV_OUT_MIN;
        }

        CLLLC_gvPartialComputedValue = CLLLC_GV_PRECOMPUTE_RUN(&CLLLC_gv,
                                                                CLLLC_gvError,
                                                                CLLLC_gvOut);

        if(CLLLC_gvOut < CLLLC_pwmPeriodMin_pu)//限制最大频率
        {
            CLLLC_gvOut = CLLLC_pwmPeriodMin_pu;
        }

        CLLLC_pwmPeriod_pu = CLLLC_gvOut;//环路输出周期长度
    }
    else//开环扫bode图?
    {

        CLLLC_gi.d4 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d5 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d6 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d7 = CLLLC_pwmPeriod_pu;

        CLLLC_gv.d4 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d5 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d6 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d7 = CLLLC_pwmPeriod_pu;

        CLLLC_giError = (CLLLC_iSecRefSlewed_pu - CLLLC_iSecSensed_pu);
        CLLLC_gi.d0 = CLLLC_giError;
        CLLLC_gi.d1 = CLLLC_giError;
        CLLLC_gi.d2 = CLLLC_giError;
        CLLLC_gi.d3 = CLLLC_giError;

        CLLLC_giPartialComputedValue = CLLLC_pwmPeriod_pu;

        CLLLC_gvError = (CLLLC_vSecRefSlewed_pu - CLLLC_vSecSensed_pu);
        CLLLC_gv.d0 = CLLLC_gvError;
        CLLLC_gv.d1 = CLLLC_gvError;
        CLLLC_gv.d2 = CLLLC_gvError;
        CLLLC_gv.d3 = CLLLC_gvError;

        CLLLC_gvPartialComputedValue = CLLLC_pwmPeriod_pu;

        #if CLLLC_INCR_BUILD == CLLLC_OPEN_LOOP_BUILD
            #if CLLLC_SFRA_TYPE != CLLLC_SFRA_DISABLED
                CLLLC_pwmPeriod_pu =
                                CLLLC_SFRA_INJECT(CLLLC_pwmPeriodRef_pu);

            #else
                CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
            #endif
        #else
            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
        #endif

        if(CLLLC_pwmPeriod_pu < CLLLC_pwmPeriodMin_pu)//输出限幅
        {
            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodMin_pu;
        }
        else if(CLLLC_pwmPeriod_pu > 1.0)
        {
            CLLLC_pwmPeriod_pu = 1.0;
        }
    }

    if(fabsf(CLLLC_pwmPeriod_pu - CLLLC_pwmPeriodSlewed_pu) >
                        CLLLC_MAX_PERIOD_STEP_PU)//将周期变化步长限制在最大步长内
    {
        if(CLLLC_pwmPeriod_pu > CLLLC_pwmPeriodSlewed_pu)
        {
            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu +
                                        CLLLC_MAX_PERIOD_STEP_PU;
        }
        else
        {
            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu -
                                        CLLLC_MAX_PERIOD_STEP_PU;
        }
    }
    else
    {
        CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriod_pu;
    }
   CLLLC_pwmFrequency_Hz = (CLLLC_PWMSYSCLOCK_FREQ_HZ /
                             (CLLLC_pwmPeriodSlewed_pu *
                              CLLLC_pwmPeriodMax_ticks));//计算频率


    #if CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT
        CLLLC_SFRA_COLLECT((float32_t *)& CLLLC_pwmPeriodSlewed_pu,
                     (float32_t *)&CLLLC_iSecSensed_pu);
    #elif CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
        CLLLC_SFRA_COLLECT((float32_t *)& CLLLC_pwmPeriodSlewed_pu,
                     (float32_t *)&CLLLC_vSecSensed_pu);
    #else
        //
        //this is the default condition, and also when SFRA is disabled
        //
        #ifndef __TMS320C28XX_CLA__
        CLLLC_slewSCIcommand++;
        if(CLLLC_slewSCIcommand > 20)
        {
            CLLLC_slewSCIcommand = 0;
            CLLLC_HAL_sendCommandOverSCI(
                       CLLLC_commandSentTo_AC_DC.CLLLC_CommandSentTo_AC_DC_Enum,
                               CLLLC_vPrimRef_Volts);
        }
        #endif
    #endif



    CLLLC_HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((CLLLC_pwmFrequencyPrev_Hz != CLLLC_pwmFrequency_Hz) ||
       (CLLLC_pwmPhaseShiftPrimSec_ns != CLLLC_pwmPhaseShiftPrimSecRef_ns) ||
       (CLLLC_pwmDutyPrim_pu != CLLLC_pwmDutyPrimRef_pu) ||
       (CLLLC_pwmDutySec_pu != CLLLC_pwmDutySecRef_pu))
    {

        CLLLC_pwmDutyPrim_pu = CLLLC_pwmDutyPrimRef_pu;//更新初级占空比
        CLLLC_pwmDutySec_pu = CLLLC_pwmDutySecRef_pu;//更新次级占空比
        CLLLC_pwmPhaseShiftPrimSec_ns = CLLLC_pwmPhaseShiftPrimSecRef_ns;//更新初级次级相移

        CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();//计算PWM占空比、周期、相移，并更新到EPWM寄存器中

        CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);//ISR1由初级桥臂EPWM的CMPC触发

        CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;

        #if CLLLC_ISR1_RUNNING_ON == CLA_CORE
              CLLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLLC_pwmFrequency_Hz,
                                          CLLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              CLLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLLC_pwmFrequency_Hz,
                                          CLLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif

    }
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR2_secToPrimPowerFlow)
static inline void CLLLC_runISR2_secToPrimPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    CLLLC_readSensedSignalsSecToPrimPowerFlow();

    if(CLLLC_clearTrip == 1)
    {
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG2_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG2_PWM_BASE);

        CLLLC_clearTrip = 0;
    }

    if(CLLLC_closeGvLoop == 1)
    {

        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_DISABLED
            CLLLC_gvError = (CLLLC_vPrimRefSlewed_pu - CLLLC_vPrimSensed_pu);
        #else
            CLLLC_gvError = (CLLLC_SFRA_INJECT(CLLLC_vPrimRefSlewed_pu) -
                                      CLLLC_vPrimSensed_pu);
        #endif

        CLLLC_gvOut = CLLLC_GV_IMMEDIATE_RUN(&CLLLC_gv,
                                       CLLLC_gvError,
                                       CLLLC_gvPartialComputedValue);

        if(CLLLC_gvOut > CLLLC_GV_OUT_MAX)
        {
            CLLLC_gvOut = CLLLC_GV_OUT_MAX;
        }
        if(CLLLC_gvOut < CLLLC_GV_OUT_MIN)
        {
            CLLLC_gvOut = CLLLC_GV_OUT_MIN;
        }

        CLLLC_gvPartialComputedValue = CLLLC_GV_PRECOMPUTE_RUN(&CLLLC_gv,
                                                        CLLLC_gvError,
                                                        CLLLC_gvOut);

        if(CLLLC_gvOut < CLLLC_pwmPeriodMin_pu)
        {
            CLLLC_gvOut = CLLLC_pwmPeriodMin_pu;
        }

        CLLLC_pwmPeriod_pu = CLLLC_gvOut;
    }
    else
    {

        CLLLC_gi.d4 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d5 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d6 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d7 = CLLLC_pwmPeriod_pu;

        CLLLC_gv.d4 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d5 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d6 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d7 = CLLLC_pwmPeriod_pu;

        CLLLC_gvError = (CLLLC_vPrimRefSlewed_pu - CLLLC_vPrimSensed_pu);
        CLLLC_gv.d0 = CLLLC_gvError;
        CLLLC_gv.d1 = CLLLC_gvError;
        CLLLC_gv.d2 = CLLLC_gvError;
        CLLLC_gv.d3 = CLLLC_gvError;

        CLLLC_gvPartialComputedValue = CLLLC_pwmPeriod_pu;

        #if CLLLC_INCR_BUILD == CLLLC_OPEN_LOOP_BUILD
            #if CLLLC_SFRA_TYPE == CLLLC_SFRA_DISABLED
                CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
            #else
                CLLLC_pwmPeriod_pu =
                        CLLLC_SFRA_INJECT(CLLLC_pwmPeriodRef_pu);
            #endif
        #else
            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
        #endif

        if(CLLLC_pwmPeriod_pu < CLLLC_pwmPeriodMin_pu)
        {
            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodMin_pu;
        }
        else if(CLLLC_pwmPeriod_pu > 1.0)
        {
            CLLLC_pwmPeriod_pu = 1.0;
        }
    }

    if(fabsf(CLLLC_pwmPeriod_pu - CLLLC_pwmPeriodSlewed_pu) >
                            CLLLC_MAX_PERIOD_STEP_PU)
    {
        if(CLLLC_pwmPeriod_pu > CLLLC_pwmPeriodSlewed_pu)
        {
            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu +
                                        CLLLC_MAX_PERIOD_STEP_PU;
        }
        else
        {
            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu -
                                        CLLLC_MAX_PERIOD_STEP_PU;
        }
    }
    else
    {
        CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriod_pu;
    }

    CLLLC_pwmFrequency_Hz = (CLLLC_PWMSYSCLOCK_FREQ_HZ /
                             (CLLLC_pwmPeriodSlewed_pu *
                              CLLLC_pwmPeriodMax_ticks));

    #if CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
        CLLLC_SFRA_COLLECT((float32_t *)&CLLLC_pwmPeriodSlewed_pu,
                               (float32_t *)&CLLLC_vPrimSensed_pu);
    #else
        #ifndef __TMS320C28XX_CLA__

        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_DISABLED

        #endif

        #endif

    #endif


    CLLLC_HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((CLLLC_pwmFrequencyPrev_Hz != CLLLC_pwmFrequency_Hz) ||
       (CLLLC_pwmPhaseShiftPrimSec_ns != CLLLC_pwmPhaseShiftPrimSecRef_ns) ||
       (CLLLC_pwmDutyPrim_pu != CLLLC_pwmDutyPrimRef_pu) ||
       (CLLLC_pwmDutySec_pu != CLLLC_pwmDutySecRef_pu))
    {

        CLLLC_pwmDutyPrim_pu = CLLLC_pwmDutyPrimRef_pu;
        CLLLC_pwmDutySec_pu = CLLLC_pwmDutySecRef_pu;
        CLLLC_pwmPhaseShiftPrimSec_ns = CLLLC_pwmPhaseShiftPrimSecRef_ns;

        CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow();

        CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);

        CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;

        #if CLLLC_ISR1_RUNNING_ON == CLA_CORE
              CLLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLLC_pwmFrequency_Hz,
                                          CLLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              CLLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLLC_pwmFrequency_Hz,
                                          CLLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif

    }
}



#ifdef __cplusplus
}
#endif                                  /* extern "C" */


#endif
